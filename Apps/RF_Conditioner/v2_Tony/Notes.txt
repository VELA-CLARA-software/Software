05/03/2020

pushd \\apclara1.dl.ac.uk\ControlRoomApps\Controllers\bin\Release

c:\Python27\python.exe pllrf_test.py

set these environment variables

EPICS_CA_ADDR_LIST=192.168.83.255
EPICS_CA_MAX_ARRAY_BYTES=100000000


10/03/2020

Hi Tony, these function should help you get the trace mean values:

        double getCutMean(const std::string&name)const;
        double getKlyFwdPwrCutMean()const;
        double getKlyFwdPhaCutMean()const;
        double getKlyRevPwrCutMean()const;
        double getKlyRevPhaCutMean()const;
        double getCavFwdPwrCutMean()const;
        double getCavFwdPhaCutMean()const;
        double getCavRevPwrCutMean()const;
        double getCavRevPhaCutMean()const;
        double getProbePwrCutMean()const;
        double getProbePhaCutMean()const;
		
11/03/2020

in llrf_controller.py: 

Read in from config file and set her, using KLYSTRON_FORWARD_POWER as an example:

	def set_trace_mean_positions(self):
		"""
		sets the mean start and end positions from the config file
		:return:
		"""
		cd =self.config_data
		c =self.config


		for trace in cd[c.MEAN_TRACES]:
			print("set_trace_mean_positions trace = ", trace)
			if 'KLYSTRON_FORWARD_POWER' in trace:
				self.llrf_control.setMeanStartEndTime(cd[c.KFPOW_MEAN_START], cd[c.KFPOW_MEAN_END], trace)
	
	
in llrf_monitor.py: 

Update all the 'simple' LLRF parameters:				
				
    def update_value(self):
        """
        Update all the 'simple' LLRF parameters, these are generally states and single numbers.
        The states can be the LLRF state, and/or a derived state (good bad, NEW_Good, NEW_BAD etc)
        required for the control of the main conditioning loop
        """
        #print("update_value LLRF clalled")
        #
        ''' send keep alive pulse'''
        # NO - do this on a seperate timeer!
        #self.llrf_control.keepAlive()

        ''' get the mean value for each trace '''
        for trace, key in self.trace_mean_keys.iteritems():
            #print("Get mean power for ", trace)
            self.get_mean_power(key, trace)
			

    def get_mean_power(self,key,trace):
        """
        get the mean reading for trace-trace and append it to values dict with key=key
        :param key: key for values dictionary, where to put the data
        :param trace: trace identifier, which trace to get data for
        """
        v = self.llrf_obj[0].trace_data[trace].mean
        #print "key = " + str(key) + ", " + trace + " mean value = " +  str(v)
        if  self.old_mean_values[trace] == v:
            pass
        else:
            self.values[key] = self.llrf_obj[0].trace_data[trace].mean
            self.old_mean_values[trace] = self.values[key]			
			
in rf_conditioning_data.py under '''Expert Values ''' on line 1040:

	mean_start_kf_pow = "mean_start_kf_pow"
    expert_value_keys.append(mean_start_kf_pow)
    expert_values[mean_start_kf_pow] = "STRING"
	
in rf_condition_view.py line 326:

    def update_mean_power_widgets(self):
        self.set_power_text(self.probe_power_outputwidget, self.values[self.data.probe_pwr])
        self.set_power_text(self.probe_power_outputwidget, self.values[self.data.probe_pwr])
        self.set_power_text(self.fwd_cav_power_outputwidget, self.values[self.data.fwd_cav_pwr])
        self.set_power_text(self.rev_cav_power_outputwidget, self.values[self.data.rev_cav_pwr])
        self.set_power_text(self.fwd_kly_power_outputwidget, self.values[self.data.fwd_kly_pwr])
        self.set_power_text(self.rev_kly_power_outputwidget, self.values[self.data.rev_kly_pwr])
	
This is successfully updating if you print out self.values[self.data.fwd_kly_pwr]


in gui_conditioning.py line 127:
	
self.timer.timeout.connect(self.update_gui)


############## Problem solved in getting the main GUI panel to read values of kly fwd rev pwr and cav fwd rec pwr:

    def set_power_text(self, widget, value):
        #widget.setText('{:0=4.2f} e6'.format(value * 0.000001))
        widget.setText('{:0=4.2f}'.format(value))


in gui_conditioning.py line 549:

self.expert_widget[self.data.mean_start_kf_pow] = self.mean_start_kf_pow  #
        self.expert_widget[self.data.mean_start_kr_pow] = self.mean_start_kr_pow  #
        self.expert_widget[self.data.mean_start_cf_pow] = self.mean_start_cf_pow  #
        self.expert_widget[self.data.mean_start_cr_pow] = self.mean_start_cr_pow  #
        self.expert_widget[self.data.mean_start_cp_pow] = self.mean_start_cp_pow  #
        self.expert_widget[self.data.mean_start_kf_pha] = self.mean_start_kf_pha  #
        self.expert_widget[self.data.mean_start_kr_pha] = self.mean_start_kr_pha  #
        self.expert_widget[self.data.mean_start_cf_pha] = self.mean_start_cf_pha  #
        self.expert_widget[self.data.mean_start_cr_pha] = self.mean_start_cr_pha  #
        self.expert_widget[self.data.mean_start_cp_pha] = self.mean_start_cp_pha  #
        self.expert_widget[self.data.mean_end_kf_pow] = self.mean_end_kf_pow  #
        self.expert_widget[self.data.mean_end_kr_pow] = self.mean_end_kr_pow  #
        self.expert_widget[self.data.mean_end_cf_pow] = self.mean_end_cf_pow  #
        self.expert_widget[self.data.mean_end_cr_pow] = self.mean_end_cr_pow  #
        self.expert_widget[self.data.mean_end_cp_pow] = self.mean_end_cp_pow  #
        self.expert_widget[self.data.mean_end_kf_pha] = self.mean_end_kf_pha  #
        self.expert_widget[self.data.mean_end_kr_pha] = self.mean_end_kr_pha  #
        self.expert_widget[self.data.mean_end_cf_pha] = self.mean_end_cf_pha  #
        self.expert_widget[self.data.mean_end_cr_pha] = self.mean_end_cr_pha  #
        self.expert_widget[self.data.mean_end_cp_pha] = self.mean_end_cp_pha  #

shell says it cannot find reference to connect.... this might be the problem

	
	
#############  SWITHCED TO CHASING CAVITY TEMPERATURE AS IT IS UPDATING LIVE ##########################

IN CONFIG.PY:
CAVITY_TEMPERATURE_PV = 'CAVITY_TEMPERATURE_PV'

IN CAVITY_TEMPERATURE_MONITOR.PY:
pv_list = self.config_data[self.config.CAVITY_TEMPERATURE_PV]

			
			
			
			